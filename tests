
import numpy as np
from scipy.constants import mu_0, pi
import matplotlib.pyplot as plt
from scipy import ndimage
import warnings
warnings.filterwarnings('ignore', category=RuntimeWarning)


def solve_cartesian(electric_current):
    
    circuit_coords = np.array([(x, y) for x, row in enumerate(electric_current) for y, val in enumerate(row) if val.any()])
    print(circuit_coords, circuit_coords[:, 0], circuit_coords[:,1])
    champ_B = np.zeros_like(electric_current)
    for x in range(electric_current.shape[0]):
        for y in range(electric_current.shape[1]):
            r = np.stack((circuit_coords[:, 0] - x, circuit_coords[:, 1] - y, np.zeros(len(circuit_coords[:, 0]))), axis=-1)
            #print(r)
            module_r = np.sqrt((r ** 2).sum(axis=-1))
            #print(module_r)
            #print(electric_current[circuit_coords[:, 0], circuit_coords[:, 1]] )
            #print(np.cross(r, electric_current[circuit_coords[:, 0], circuit_coords[:, 1]])[:, 2])
            B = np.cross(r, electric_current[circuit_coords[:, 0], circuit_coords[:, 1]])[:, 2] / (module_r ** 3)
            champ_B[x, y][2] = np.sum(B, axis=0)
            #print(champ_B)
            
    return np.nan_to_num(mu_0 * champ_B / (4 * np.pi), nan=0)






vecto = np.array([[[1., 0., 0.], [1., 0., 0.], [1., 0., 0.], [0., 1., 0.]], [[0., 1., 0.], [0., 0., 0.], [0., 0., 0.], [0., 1., 0.]], [[0., 1., 0.], [0., 0., 0.], [0., 0., 0.], [0., 1., 0.]], [[0., 1., 0.], [0., 0., 0.], [0., 0., 0.], [0., 1., 0.]], [[0., 1., 0.], [1., 0., 0.], [1., 0., 0.], [1., 0., 0.]]])
#print(vecto)
#plt.imshow(vecto)
#plt.show()
print(solve_cartesian(vecto))
plt.imshow(solve_cartesian(vecto))
plt.show()


